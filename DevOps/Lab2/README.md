# Отчёт по лабораторной работе DevOps2

## Техническое задание
1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов;
2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены;
3. В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат;
4. В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

## Установка Docker

Обновляем пакеты
```bash
sudo apt update
```

Устанавливаем дополнительные пакеты
```bash
sudo apt install curl software-properties-common ca-certificates apt-transport-https -y
```
Импортируем GPG-ключ
```bash
wget -O- https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor | sudo tee /etc/apt/keyrings/docker.gpg > /dev/null
```

Добавляем репозиторий докера
```bash
echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu jammy stable"| sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

Еще раз обновляем пакеты
```bash
sudo apt update
```

Проверяем репозиторий
```bash
apt-cache policy docker-ce
```

Устанавливаем Docker
```bash
sudo apt install docker-ce -y
```

Проверяем статус докера
```bash
sudo systemctl status docker
```

Результат проверки:
![проверка статуса докера](https://github.com/paltovkletku/babaiki_devops_clouds/blob/main/DevOps/Lab2/images/docker%20running.jpg)

## Написание "плохого" Dockerfile

Напишем докерфайл с ошибками, а затем разберем их.
```bash
FROM ubuntu:latest

RUN apt-get update

RUN apt-get install bash

RUN apt-get install -y vim

RUN apt-get install -y curl

ADD https://raw.githubusercontent.com/paltovkletku/babaiki_devops_clouds/main/DevOps/Lab2/happy.bash .

CMD ["bash", "happy.bash"]
```

![плохой докерфайл](https://github.com/paltovkletku/babaiki_devops_clouds/blob/main/DevOps/Lab2/images/bad.jpg)

Bad practices:

1. Использование ubuntu:latest в качестве базового образа. latest подразумевает использование последнего доступного образа ubuntu, то есть он может меняться со временем, что может вызвать проблемы в работе с контейнером и непредсказуемое поведение. Кроме того, отличная от изначальной версии может привести к проблемам совместимости или к уязвимостям в безопасности.
   
2. Множественные инструкции RUN. Каждая run-инструкция подразумевает создание нового слоя. Так, все выполняющиеся инструкции при сборке docker-образа влекут за собой увеличение его размера. В нашем случае создается 4 слоя в образе. Также связанные между собой команды стоит объединять под одной run-инструкцией, то есть, например, RUN apt-get update и RUN apt-get install bash стоило бы объединять, чтобы не увеличивать размер образа, а также убедиться, что установка bash произойдет только при условии успешного обновления.

3. Установка избыточных пакетов. Более того, мы устанавливаем абсолютно не нужные нам vim и curl, что является плохой практикой, так как влияет на размер образа и может понизить безопасность. Такой подход может повлечь за собой проблемы при загрузке и выгрузке образа, а также замедлить процесс сборки.

4. Добавление файла через url-ссылку, использование ADD вместо COPY. Добавлять файлы в образ, ссылаясь на url - не очень хорошая практика. Инструкция ADD автоматически извлекает url-адреса, что может привести к уязвимостям безопасности, если url-адрес содержит вредоносный код. ADD может затруднить отслеживание происхождения файлов, что усложнит поддержание целостности файлов и отслеживание изменений. Копируя код из чужих удаленных директорий (да и из своих тоже), стоит иметь в виду, что содержимое директории может измениться со временем, и при новой сборке образа мы можем получить что-то совсем неожиданное.

## Написание "хорошего" Dockerfile

```bash
FROM ubuntu:22.04

COPY happy.bash .

ENTRYPOINT ["bash"]

CMD ["happy.bash"]
```

![хороший докерфайл run](https://github.com/paltovkletku/babaiki_devops_clouds/blob/main/DevOps/Lab2/images/good.jpg)

Изменения:

1. Теперь в качестве базового образа будет всегда использоваться Ubuntu 22.04 - определенная версия образа ubuntu, которая не изменится без нашего ведома.

2. Мы избавились от избыточных инструкций RUN. То есть от всех них)) vim и curl не были нужны нам изначально. Дальше путем нехитрых умозаключений, мы поняли, что нам не нужно устанавливать bash явно, так как bash уже имеется в образе Ubuntu. Таким образом мы оптимизировали образ, он стал читабельнее и эффективнее + мы избавили себя от возможных конфликтов версий bash или его повторной установки.

3. Ранее мы использовали ADD инструкцию для извлечения файла из URL и добавления его в наш образ Docker. Теперь мы перешли на использование COPY-инструкцию для включения файлов в наш образ Docker. Мы копируем файлы из локальной директории lab2, а не извлекаем их по URL. Это позволило обеспечить более безопасную и быструю работу.

4. Также была добавлена инструкция ENTRYPOINT в сочетании с CMD. ENTRYPOINT используется для указания исполняемого файла, который должен быть запущен при запуске контейнера, а CMD - для указания команды по умолчанию.

5. Указана рабочая директория. Так мы сократили себе работу по указанию полного пути до файла - profit. Добавили предсказуемости - теперь мы всегда знаем, куда класть файлы, чтобы они обязательно нашлись - так проще дебажить. Указанная рабочая директория может помочь сократить количество копируемых файлов и каталогов (не в нашем случае). Правда, здесь нужно быть осторожнее, потому что такое указание рабочей директории может сказаться на гибкости.

## "Bad practices" по работе с контейнерами

1. Запуск контейнеров с правами root. Это плохая практика, которая может привести к существенным уязвимостям безопасности и эксплуатации. Такой подход может поставить под угрозу целостность системы и допустить утечку конфиденциальных данных. Можно использовать --user флаг при запуске контейнера для указания идентификаторов пользователя и группы.
2. Неограниченное распределение ресурсов. Предоставление контейнеру неограниченного доступа к системным ресурсам, таким как память и ЦП, может привести к значительным рискам безопасности и эксплуатации.
