# Отчёт по лабораторной работе DevOps2

## Техническое задание
1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов;
2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены;
3. В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат;
4. В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

## Установка Docker

Обновляем пакеты
```bash
sudo apt update
```

Устанавливаем дополнительные пакеты
```bash
sudo apt install curl software-properties-common ca-certificates apt-transport-https -y
```
Импортируем GPG-ключ
```bash
wget -O- https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor | sudo tee /etc/apt/keyrings/docker.gpg > /dev/null
```

Добавляем репозиторий докера
```bash
echo "deb [arch=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu jammy stable"| sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

Еще раз обновляем пакеты
```bash
sudo apt update
```

Проверяем репозиторий
```bash
apt-cache policy docker-ce
```

Устанавливаем Docker
```bash
sudo apt install docker-ce -y
```

Проверяем статус докера
```bash
sudo systemctl status docker
```

Результат проверки:
![проверка статуса докера](https://github.com/paltovkletku/babaiki_devops_clouds/blob/main/DevOps/Lab2/images/docker%20running.jpg)

## Написание "плохого" Dockerfile

Напишем докерфайл с ошибками, а затем разберем их.
```bash
FROM ubuntu:latest

RUN apt-get update

RUN apt-get install bash

RUN apt-get install -y vim

RUN apt-get install -y curl

ADD https://raw.githubusercontent.com/paltovkletku/babaiki_devops_clouds/main/DevOps/Lab2/happy.bash .

CMD ["bash", "happy.bash"]
```

![плохой докерфайл](https://github.com/paltovkletku/babaiki_devops_clouds/blob/main/DevOps/Lab2/images/bad.jpg)

Bad practices:

1. Использование ubuntu:latest в качестве базового образа. latest подразумевает использование последнего доступного образа ubuntu, то есть он может меняться со временем, что может вызвать проблемы в работе с контейнером и непредсказуемое поведение. Кроме того, отличная от изначальной версии может привести к проблемам совместимости или к уязвимостям в безопасности.
   
2. Множественные инструкции RUN. Каждая run-инструкция подразумевает создание нового слоя. Так, все выполняющиеся инструкции при сборке docker-образа влекут за собой увеличение его размера. В нашем случае создается 4 слоя в образе. Также связанные между собой команды стоит объединять под одной run-инструкцией, то есть, например, RUN apt-get update и RUN apt-get install bash стоило бы объединять, чтобы не увеличивать размер образа, а также убедиться, что установка bash произойдет только при условии успешного обновления.

3. Добавление файла через url-ссылку, использование ADD вместо COPY. Добавлять файлы в образ, ссылаясь на url - не очень хорошая практика. Инструкция ADD автоматически извлекает url-адреса, что может привести к уязвимостям безопасности, если url-адрес содержит вредоносный код. ADD может затруднить отслеживание происхождения файлов, что усложнит поддержание целостности файлов и отслеживание изменений. Копируя код из чужих удаленных директорий (да и из своих тоже), стоит иметь в виду, что содержимое директории может измениться со временем, и при новой сборке образа мы можем получить что-то совсем неожиданное.

## Написание "хорошего" Dockerfile

```bash
FROM ubuntu:22.04

WORKDIR /lab2

RUN apt-get update &&
apt-get install -y vim curl &&
apt-get clean &&
rm -rf /var/lib/apt/lists/*

COPY happy.bash .

ENTRYPOINT ["bash"]

CMD ["happy.bash"]
```

![хороший докерфайл run](https://github.com/paltovkletku/babaiki_devops_clouds/blob/main/DevOps/Lab2/images/good.jpg)

Изменения:

1. Теперь в качестве базового образа будет всегда использоваться Ubuntu 22.04 - определенная версия образа ubuntu, которая не изменится без нашего ведома.

2. Мы избавились от избыточных инструкций RUN. Путем нехитрых умозаключений, мы поняли, что нам не нужно устанавливать bash явно, так как bash уже имеется в образе Ubuntu. Уставноку vim и curl объединили в один слой (+ добавили очистку кэша, чтобы уменьшить размер образа). Так мы оптимизировали образ, сократив число слоев и сделав его эффективнее (и сохранив установку всех инструментов!!)

3. Ранее мы использовали ADD инструкцию для извлечения файла из URL и добавления его в наш образ Docker. Теперь мы перешли на использование COPY-инструкцию для включения файлов в наш образ Docker. Мы копируем файлы из локальной директории lab2, а не извлекаем их по URL. Это позволило обеспечить более безопасную и быструю работу.

4. Также была добавлена инструкция ENTRYPOINT в сочетании с CMD. ENTRYPOINT используется для указания исполняемого файла, который должен быть запущен при запуске контейнера - в нашем случае оболочка bash, а CMD - для указания команды и параметров по умолчанию, она выполнится при запуске контейнера. Это обеспечивает гибкий способ указания команды и параметров по умолчанию для контейнера, в то же время позволяя пользователю переопределять их при необходимости.

5. Указана рабочая директория. Так мы сократили себе работу по указанию полного пути до файла - profit. Добавили предсказуемости - теперь мы всегда знаем, куда класть файлы, чтобы они обязательно нашлись - так проще дебажить. Указанная рабочая директория может помочь сократить количество копируемых файлов и каталогов (не в нашем случае). Правда, здесь нужно быть осторожнее, потому что такое указание рабочей директории может сказаться на гибкости.

## "Bad practices" по работе с контейнерами

1. Запуск контейнеров с правами root.
  
   Это плохая практика, которая может привести к существенным уязвимостям безопасности и эксплуатации. Такой подход может поставить под угрозу целостность системы и допустить утечку конфиденциальных данных. Если кто-то со стороны получит доступ к такому контейнеру, то он сможет получить доступ к нашей основной системе, т.к. контейнер имеет доступ к ее ресурсам. Можно использовать --user флаг при запуске контейнера для указания идентификаторов пользователя и группы.

2. Неограниченное распределение ресурсов.

   Предоставление контейнеру неограниченный доступ к системным ресурсам, таким как память и cpu, может привести к значительным рискам безопасности и эксплуатации. Контейнер может потреблять все доступные ресурсы, что приводит к сбоям системы, замедлению работы или даже полному отказу системы (вспомнили запуск aafire при выполнении лабораторной работы по информатике и прослезились).

3. Данные внутри контейнера.

   Жизненный цикл контейнера может включать паузы, завершения и замены. Если приложение работает внутри контейнера, важно гарантировать, что данные не будут потеряны или скомпрометированы при обновлении или замене контейнера. Поэтому рекомендуется хранить данные вне контейнера, обычно на постоянном томе хранилища. Таким образом, даже если контейнер будет перезапущен или заменен, данные останутся в сохранности. При этом важно следить за тем, чтобы несколько контейнеров не записывали данные в одно и то же место - это может привести к повреждению или несогласованности данных.

## А сейчас топ-3 мема, сделанных нашими лапками

![правильный выбор](https://github.com/paltovkletku/babaiki_devops_clouds/blob/main/DevOps/Lab2/images/%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9%20%D0%B2%D1%8B%D0%B1%D0%BE%D1%80.jpg)

![мы при выполнении лабы](https://github.com/paltovkletku/babaiki_devops_clouds/blob/main/DevOps/Lab2/images/%D0%BC%D1%8B%20%D0%BF%D1%80%D0%B8%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B8%20%D0%BB%D0%B0%D0%B1%D1%8B.jpg)

![сверхразум](https://github.com/paltovkletku/babaiki_devops_clouds/blob/main/DevOps/Lab2/images/%D1%81%D0%B2%D0%B5%D1%80%D1%85%D1%80%D0%B0%D0%B7%D1%83%D0%BC.jpg)

Выполнили: Борисевич Анна, Ходакова Мария.
